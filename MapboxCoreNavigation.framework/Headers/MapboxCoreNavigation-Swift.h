// Generated by Apple Swift version 4.2.1 effective-4.1.50 (swiftlang-1000.11.42 clang-1000.11.45.1)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <objc/NSObject.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if __has_feature(modules)
@import AVFoundation;
@import CoreLocation;
@import Foundation;
@import MapboxDirections;
@import MapboxMobileEvents;
@import MapboxNavigationNative;
@import ObjectiveC;
@import UIKit;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="MapboxCoreNavigation",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif




@interface NSBundle (SWIFT_EXTENSION(MapboxCoreNavigation))
/// The Mapbox Core Navigation framework bundle.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) NSBundle * _Nonnull mapboxCoreNavigation;)
+ (NSBundle * _Nonnull)mapboxCoreNavigation SWIFT_WARN_UNUSED_RESULT;
/// A file URL representing a directory in which the application can place downloaded tile files.
@property (nonatomic, readonly, copy) NSURL * _Nullable suggestedTileURL;
/// A file URL at which the application can place a downloaded tile file with the given version identifier.
- (NSURL * _Nullable)suggestedTileURLWithVersion:(NSString * _Nonnull)version SWIFT_WARN_UNUSED_RESULT;
@end






/// :nodoc: Internal “using default interaface” flag. Used for telemetry.
SWIFT_PROTOCOL_NAMED("DefaultInterfaceFlag")
@protocol MBDefaultInterfaceFlag
/// :nodoc: Internal “using default interaface” flag. Used for telemetry.
@property (nonatomic) BOOL usesDefaultUserInterface;
@end

@class NSCoder;
@class NSUnitLength;
@class NSAttributedString;

/// Provides appropriately formatted, localized descriptions of linear distances.
SWIFT_CLASS_NAMED("DistanceFormatter")
@interface MBDistanceFormatter : NSLengthFormatter
/// Intializes a new <code>DistanceFormatter</code>.
/// \param approximate approximates the distances.
///
- (nonnull instancetype)initWithApproximate:(BOOL)approximate OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder OBJC_DESIGNATED_INITIALIZER;
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
/// Returns a more human readable <code>String</code> from a given <code>CLLocationDistance</code>.
/// The user’s <code>Locale</code> is used here to set the units.
- (NSString * _Nonnull)stringFrom:(CLLocationDistance)distance SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)stringFromMeters:(double)numberInMeters SWIFT_WARN_UNUSED_RESULT;
- (NSMeasurement<NSUnitLength *> * _Nonnull)measurementOfDistance:(CLLocationDistance)distance SWIFT_WARN_UNUSED_RESULT SWIFT_AVAILABILITY(ios,introduced=10.0);
/// Returns an attributed string containing the formatted, converted distance.
/// <code>NSAttributedStringKey.quantity</code> is applied to the numeric quantity.
- (NSAttributedString * _Nullable)attributedStringForObjectValue:(id _Nonnull)obj withDefaultAttributes:(NSDictionary<NSAttributedStringKey, id> * _Nullable)attrs SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end

@class NSNumber;

/// Feedback Model Object for End Of Route Experience.
SWIFT_CLASS("_TtC20MapboxCoreNavigation18EndOfRouteFeedback")
@interface EndOfRouteFeedback : NSObject
- (nonnull instancetype)initWithRating:(NSNumber * _Nullable)ratingNumber comment:(NSString * _Nullable)comment;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end

@class MBRouteProgress;
@class MBNavigationLocationManager;

/// The <code>EventsManagerDataSource</code> protocol declares values required for recording route following events.
SWIFT_PROTOCOL("_TtP20MapboxCoreNavigation23EventsManagerDataSource_")
@protocol EventsManagerDataSource
@property (nonatomic, readonly, strong) MBRouteProgress * _Nonnull routeProgress;
@property (nonatomic, readonly, strong) CLLocation * _Nullable location;
@property (nonatomic, readonly) CLLocationAccuracy desiredAccuracy;
@property (nonatomic, readonly) SWIFT_METATYPE(MBNavigationLocationManager) _Nonnull locationProvider;
@end

typedef SWIFT_ENUM_NAMED(NSInteger, MBFeedbackSource, "FeedbackSource", closed) {
  MBFeedbackSourceUser = 0,
  MBFeedbackSourceReroute = 1,
  MBFeedbackSourceUnknown = 2,
};

/// Feedback type is used to specify the type of feedback being recorded with <code>NavigationEventsManager.recordFeedback(type:description:)</code>.
typedef SWIFT_ENUM_NAMED(NSInteger, MBFeedbackType, "FeedbackType", closed) {
/// Indicates general feedback. You should provide a <code>description</code> string to <code>NavigationEventsManager.recordFeedback(type:description:)</code> to elaborate on the feedback if possible.
  MBFeedbackTypeGeneral = 0,
/// Identifies the feedback as the location of an accident or crash
  MBFeedbackTypeAccident = 1,
/// Identifies the feedback as the location of a road hazard such as debris, stopped vehicles, etc.
  MBFeedbackTypeHazard = 2,
/// Identifies the feedback as the location of a closed road that should not allow vehicles
  MBFeedbackTypeRoadClosed = 3,
/// Identifies the feedback as a maneuver that isn’t allowed. For example, if a user is instructed to make a left turn, but the turn isn’t allowed.
  MBFeedbackTypeNotAllowed = 4,
/// Identifies the feedback as the location of a road that should exist along the route.
  MBFeedbackTypeMissingRoad = 5,
/// Identifies the feedback as a maneuver with missing exit information such as an exit number or destination sign.
  MBFeedbackTypeMissingExit = 6,
/// Identifies the feedback as the location of a poor instruction or route choice. This could be used to indicate an ambiguous or poorly-timed turn announcement, or a set of confusing turns.
  MBFeedbackTypeRoutingError = 7,
/// Identifies the feedback as the location of a confusing instruction.
  MBFeedbackTypeConfusingInstruction = 8,
/// Identifies the feedback as a place where traffic should have been reported.
  MBFeedbackTypeReportTraffic = 9,
/// Identifies the feedback as a general map issue.
  MBFeedbackTypeMapIssue = 10,
};

@protocol MBRouterDataSource;
@protocol MBRouterDelegate;
@class MBRoute;
@class MBDirections;

SWIFT_PROTOCOL("_TtP20MapboxCoreNavigation6Router_")
@protocol Router <CLLocationManagerDelegate>
/// The route controller’s associated location manager.
@property (nonatomic, readonly, assign) id <MBRouterDataSource> _Nonnull dataSource;
/// The route controller’s delegate.
@property (nonatomic, strong) id <MBRouterDelegate> _Nullable delegate;
/// Intializes a new <code>RouteController</code>.
/// \param route The route to follow.
///
/// \param directions The Directions object that created <code>route</code>.
///
/// \param source The data source for the RouteController.
///
- (nonnull instancetype)initWithRoute:(MBRoute * _Nonnull)route directions:(MBDirections * _Nonnull)directions dataSource:(id <MBRouterDataSource> _Nonnull)source;
/// Details about the user’s progress along the current route, leg, and step.
@property (nonatomic, readonly, strong) MBRouteProgress * _Nonnull routeProgress;
@property (nonatomic, strong) MBRoute * _Nonnull route;
/// Given a users current location, returns a Boolean whether they are currently on the route.
/// If the user is not on the route, they should be rerouted.
- (BOOL)userIsOnRoute:(CLLocation * _Nonnull)location SWIFT_WARN_UNUSED_RESULT;
- (void)rerouteFrom:(CLLocation * _Nonnull)from along:(MBRouteProgress * _Nonnull)along;
/// The idealized user location. Snapped to the route line, if applicable, otherwise raw or nil.
@property (nonatomic, readonly, strong) CLLocation * _Nullable location;
/// Advances the leg index.
/// This is a convienence method provided to advance the leg index of any given router without having to worry about the internal data structure of the router.
- (void)advanceLegIndexWithLocation:(CLLocation * _Nonnull)location;
@optional
- (void)enableLocationRecording;
- (void)disableLocationRecording;
- (NSString * _Nonnull)locationHistory SWIFT_WARN_UNUSED_RESULT;
@end

@class CLLocationManager;
@class CLHeading;
@class MBNavigationEventsManager;

SWIFT_CLASS_NAMED("LegacyRouteController") SWIFT_DEPRECATED_MSG("", "RouteController")
@interface MBLegacyRouteController : NSObject <Router>
@property (nonatomic, weak) id <MBRouterDelegate> _Nullable delegate;
@property (nonatomic, assign) id <MBRouterDataSource> _Nonnull dataSource;
/// The Directions object used to create the route.
@property (nonatomic, strong) MBDirections * _Nonnull directions;
/// The threshold used when we determine when the user has arrived at the waypoint.
/// By default, we claim arrival 5 seconds before the user is physically estimated to arrive.
@property (nonatomic) NSTimeInterval waypointArrivalThreshold;
/// If true, the <code>RouteController</code> attempts to calculate a more optimal route for the user on an interval defined by <code>RouteControllerProactiveReroutingInterval</code>.
@property (nonatomic) BOOL reroutesProactively;
@property (nonatomic, strong) MBRouteProgress * _Nonnull routeProgress;
@property (nonatomic, strong) MBRoute * _Nonnull route;
- (nonnull instancetype)initWithRoute:(MBRoute * _Nonnull)route directions:(MBDirections * _Nonnull)directions dataSource:(id <MBRouterDataSource> _Nonnull)source OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, readonly, strong) CLLocation * _Nullable location;
@property (nonatomic, readonly) CLLocationDistance reroutingTolerance;
- (BOOL)userIsOnRoute:(CLLocation * _Nonnull)location SWIFT_WARN_UNUSED_RESULT;
- (void)advanceLegIndexWithLocation:(CLLocation * _Nonnull)location;
- (void)locationManager:(CLLocationManager * _Nonnull)manager didUpdateHeading:(CLHeading * _Nonnull)newHeading;
- (void)locationManager:(CLLocationManager * _Nonnull)manager didUpdateLocations:(NSArray<CLLocation *> * _Nonnull)locations;
- (void)rerouteFrom:(CLLocation * _Nonnull)location along:(MBRouteProgress * _Nonnull)progress;
- (nonnull instancetype)initWithRoute:(MBRoute * _Nonnull)route directions:(MBDirections * _Nonnull)directions dataSource:(MBNavigationLocationManager * _Nonnull)dataSource eventsManager:(MBNavigationEventsManager * _Nonnull)eventsManager;
@property (nonatomic, strong) MBNavigationLocationManager * _Null_unspecified locationManager;
@property (nonatomic) id _Null_unspecified tunnelIntersectionManager;
@property (nonatomic, strong) MBNavigationEventsManager * _Null_unspecified eventsManager;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end






SWIFT_PROTOCOL_NAMED("RouterDataSource")
@protocol MBRouterDataSource
@property (nonatomic, readonly, strong) CLLocation * _Nullable location;
@property (nonatomic, readonly) SWIFT_METATYPE(MBNavigationLocationManager) _Nonnull locationProvider;
@end

enum MBNavigationSimulationOptions : NSInteger;
@protocol NavigationServiceDelegate;

/// A <code>NavigationService</code> is the entry-point protocol for MapboxCoreNavigation.
/// It contains all the dependencies needed by the <code>MapboxNavigation</code> UI SDK, as well as dependencies for its child objects.
/// <code>MapboxNavigationService</code> is the default implementation.
/// If you would like to implement your own core-navigation stack, be sure to conform to this protocol.
SWIFT_PROTOCOL_NAMED("NavigationService")
@protocol MBNavigationService <CLLocationManagerDelegate, MBDefaultInterfaceFlag, EventsManagerDataSource, MBRouterDataSource>
/// The location manager for the service. This will be the object responsible for notifying the service of GPS updates.
@property (nonatomic, readonly, strong) MBNavigationLocationManager * _Nonnull locationManager;
/// A reference to a MapboxDirections service. Used for rerouting.
@property (nonatomic, readonly, strong) MBDirections * _Nonnull directions;
/// The active router, responsible for all route-following.
@property (nonatomic, readonly, strong) id <Router> _Null_unspecified router;
/// The events manager, responsible for all telemetry.
@property (nonatomic, readonly, strong) MBNavigationEventsManager * _Null_unspecified eventsManager;
/// The route along which the user is expected to travel.
@property (nonatomic, strong) MBRoute * _Nonnull route;
/// The simulation mode of the service.
@property (nonatomic) enum MBNavigationSimulationOptions simulationMode;
/// The simulation speed-multiplier. Modify this if you desire accelerated simulation.
@property (nonatomic) double simulationSpeedMultiplier;
/// The Amount of time the service will wait until it begins simulation in a poor GPS scenerio. Defaults to 2.5 seconds.
@property (nonatomic) double poorGPSPatience;
/// The <code>NavigationService</code> delegate. Wraps <code>RouterDelegate</code> messages.
@property (nonatomic, weak) id <NavigationServiceDelegate> _Nullable delegate;
/// Starts the navigation service.
- (void)start;
/// Stops the navigation service. You may call <code>start()</code> after calling <code>stop()</code>.
- (void)stop;
/// Ends the navigation session. Used when arriving at destination.
- (void)endNavigationWithFeedback:(EndOfRouteFeedback * _Nullable)feedback;
/// Interrogates the navigationService as to whether or not the passed-in location is in a tunnel.
- (BOOL)isInTunnelAt:(CLLocation * _Nonnull)location along:(MBRouteProgress * _Nonnull)progress SWIFT_WARN_UNUSED_RESULT;
@end


/// A <code>NavigationService</code> is the entry-point interface into MapboxCoreNavigation. This service manages a <code>locationManager</code> (which feeds it location updates), a <code>Directions</code> service (for rerouting), a <code>Router</code> (for route-following), a <code>NavigationEventsManager</code> (for telemetry), and a simulation engine for use during poor GPS conditions.
SWIFT_CLASS_NAMED("MapboxNavigationService")
@interface MBNavigationService : NSObject <MBNavigationService>
/// The Amount of time the service will wait until it begins simulation in a poor GPS scenerio. Defaults to 2.5 seconds.
@property (nonatomic) double poorGPSPatience;
/// The active location manager. Returns the location simulator if we’re actively simulating, otherwise it returns the native location manager.
@property (nonatomic, readonly, strong) MBNavigationLocationManager * _Nonnull locationManager;
/// A reference to a MapboxDirections service. Used for rerouting.
@property (nonatomic, strong) MBDirections * _Nonnull directions;
/// The active router. By default, a <code>PortableRouteController</code>.
@property (nonatomic, strong) id <Router> _Null_unspecified router;
/// The events manager. Sends telemetry back to the Mapbox platform.
@property (nonatomic, strong) MBNavigationEventsManager * _Null_unspecified eventsManager;
/// The <code>NavigationService</code> delegate. Wraps <code>RouterDelegate</code> messages.
@property (nonatomic, weak) id <NavigationServiceDelegate> _Nullable delegate;
/// The simulation mode of the service.
@property (nonatomic) enum MBNavigationSimulationOptions simulationMode;
/// The simulation speed multiplier. If you desire the simulation to go faster than real-time, increase this value.
@property (nonatomic) double simulationSpeedMultiplier;
/// :nodoc: Internal Telemetry flag.
@property (nonatomic) BOOL usesDefaultUserInterface;
/// Intializes a new <code>NavigationService</code>.
/// \param route The route to follow.
///
/// \param directions The Directions object that created <code>route</code>.
///
/// \param locationSource An optional override for the default <code>NaviationLocationManager</code>.
///
/// \param eventsManagerType An optional events manager type to use while tracking the route.
///
/// \param simulationMode The simulation mode desired.
///
/// \param routerType An optional router type to use for traversing the route.
///
- (nonnull instancetype)initWithRoute:(MBRoute * _Nonnull)route directions:(MBDirections * _Nullable)directions locationSource:(MBNavigationLocationManager * _Nullable)locationSource eventsManagerType:(SWIFT_METATYPE(MBNavigationEventsManager) _Nullable)eventsManagerType simulating:(enum MBNavigationSimulationOptions)simulationMode routerType:(Class <Router> _Nullable)routerType OBJC_DESIGNATED_INITIALIZER;
/// Determines if a location is within a tunnel.
/// \param location The location to test.
///
/// \param progress the RouteProgress model that contains the route geometry.
///
- (BOOL)isInTunnelAt:(CLLocation * _Nonnull)location along:(MBRouteProgress * _Nonnull)progress SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, strong) MBRoute * _Nonnull route;
- (void)start;
- (void)stop;
- (void)endNavigationWithFeedback:(EndOfRouteFeedback * _Nullable)feedback;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end


@interface MBNavigationService (SWIFT_EXTENSION(MapboxCoreNavigation)) <CLLocationManagerDelegate>
- (void)locationManager:(CLLocationManager * _Nonnull)manager didUpdateHeading:(CLHeading * _Nonnull)newHeading;
- (void)locationManager:(CLLocationManager * _Nonnull)manager didUpdateLocations:(NSArray<CLLocation *> * _Nonnull)locations;
@end


@interface MBNavigationService (SWIFT_EXTENSION(MapboxCoreNavigation))
@property (nonatomic, readonly) SWIFT_METATYPE(MBNavigationLocationManager) _Nonnull locationProvider;
@end


@interface MBNavigationService (SWIFT_EXTENSION(MapboxCoreNavigation))
@property (nonatomic, readonly, strong) MBRouteProgress * _Nonnull routeProgress;
@property (nonatomic, readonly, strong) CLLocation * _Nullable location;
@property (nonatomic, readonly) CLLocationAccuracy desiredAccuracy;
@end

@class MBVisualInstructionBanner;
@class MBSpokenInstruction;
@class MBWaypoint;

SWIFT_PROTOCOL_NAMED("RouterDelegate")
@protocol MBRouterDelegate
@optional
- (BOOL)router:(id <Router> _Nonnull)router shouldRerouteFromLocation:(CLLocation * _Nonnull)location SWIFT_WARN_UNUSED_RESULT;
- (void)router:(id <Router> _Nonnull)router willRerouteFromLocation:(CLLocation * _Nonnull)location;
- (BOOL)router:(id <Router> _Nonnull)router shouldDiscardLocation:(CLLocation * _Nonnull)location SWIFT_WARN_UNUSED_RESULT;
- (void)router:(id <Router> _Nonnull)router didRerouteAlongRoute:(MBRoute * _Nonnull)route at:(CLLocation * _Nullable)location proactive:(BOOL)proactive;
- (void)router:(id <Router> _Nonnull)router didFailToRerouteWithError:(NSError * _Nonnull)error;
- (void)router:(id <Router> _Nonnull)router didUpdateProgress:(MBRouteProgress * _Nonnull)progress withLocation:(CLLocation * _Nonnull)location rawLocation:(CLLocation * _Nonnull)rawLocation;
- (void)router:(id <Router> _Nonnull)router didPassVisualInstructionPoint:(MBVisualInstructionBanner * _Nonnull)instruction routeProgress:(MBRouteProgress * _Nonnull)routeProgress;
- (void)router:(id <Router> _Nonnull)router didPassSpokenInstructionPoint:(MBSpokenInstruction * _Nonnull)instruction routeProgress:(MBRouteProgress * _Nonnull)routeProgress;
- (void)router:(id <Router> _Nonnull)router willArriveAtWaypoint:(MBWaypoint * _Nonnull)waypoint in:(NSTimeInterval)remainingTimeInterval distance:(CLLocationDistance)distance;
- (BOOL)router:(id <Router> _Nonnull)router didArriveAtWaypoint:(MBWaypoint * _Nonnull)waypoint SWIFT_WARN_UNUSED_RESULT;
- (BOOL)router:(id <Router> _Nonnull)router shouldPreventReroutesWhenArrivingAtWaypoint:(MBWaypoint * _Nonnull)waypoint SWIFT_WARN_UNUSED_RESULT;
- (BOOL)routerShouldDisableBatteryMonitoring:(id <Router> _Nonnull)router SWIFT_WARN_UNUSED_RESULT;
@end


@interface MBNavigationService (SWIFT_EXTENSION(MapboxCoreNavigation)) <MBRouterDelegate>
- (void)router:(id <Router> _Nonnull)router willRerouteFromLocation:(CLLocation * _Nonnull)location;
- (void)router:(id <Router> _Nonnull)router didRerouteAlongRoute:(MBRoute * _Nonnull)route at:(CLLocation * _Nullable)location proactive:(BOOL)proactive;
- (void)router:(id <Router> _Nonnull)router didFailToRerouteWithError:(NSError * _Nonnull)error;
- (void)router:(id <Router> _Nonnull)router didUpdateProgress:(MBRouteProgress * _Nonnull)progress withLocation:(CLLocation * _Nonnull)location rawLocation:(CLLocation * _Nonnull)rawLocation;
- (void)router:(id <Router> _Nonnull)router didPassVisualInstructionPoint:(MBVisualInstructionBanner * _Nonnull)instruction routeProgress:(MBRouteProgress * _Nonnull)routeProgress;
- (void)router:(id <Router> _Nonnull)router didPassSpokenInstructionPoint:(MBSpokenInstruction * _Nonnull)instruction routeProgress:(MBRouteProgress * _Nonnull)routeProgress;
- (BOOL)router:(id <Router> _Nonnull)router shouldRerouteFromLocation:(CLLocation * _Nonnull)location SWIFT_WARN_UNUSED_RESULT;
- (BOOL)router:(id <Router> _Nonnull)router shouldDiscardLocation:(CLLocation * _Nonnull)location SWIFT_WARN_UNUSED_RESULT;
- (void)router:(id <Router> _Nonnull)router willArriveAtWaypoint:(MBWaypoint * _Nonnull)waypoint in:(NSTimeInterval)remainingTimeInterval distance:(CLLocationDistance)distance;
- (BOOL)router:(id <Router> _Nonnull)router didArriveAtWaypoint:(MBWaypoint * _Nonnull)waypoint SWIFT_WARN_UNUSED_RESULT;
- (BOOL)router:(id <Router> _Nonnull)router shouldPreventReroutesWhenArrivingAtWaypoint:(MBWaypoint * _Nonnull)waypoint SWIFT_WARN_UNUSED_RESULT;
- (BOOL)routerShouldDisableBatteryMonitoring:(id <Router> _Nonnull)router SWIFT_WARN_UNUSED_RESULT;
@end

@class MBRouteOptions;
@class NSError;

/// A <code>NavigationDirections</code> object provides you with optimal directions between different locations, or waypoints. The directions object passes your request to a built-in routing engine and returns the requested information to a closure (block) that you provide. A directions object can handle multiple simultaneous requests. A <code>RouteOptions</code> object specifies criteria for the results, such as intermediate waypoints, a mode of transportation, or the level of detail to be returned. In addition to <code>Directions</code>, <code>NavigationDirections</code> provides support for offline routing.
/// Each result produced by the directions object is stored in a <code>Route</code> object. Depending on the <code>RouteOptions</code> object you provide, each route may include detailed information suitable for turn-by-turn directions, or it may include only high-level information such as the distance, estimated travel time, and name of each leg of the trip. The waypoints that form the request may be conflated with nearby locations, as appropriate; the resulting waypoints are provided to the closure.
SWIFT_CLASS_NAMED("NavigationDirections")
@interface MBNavigationDirections : MBDirections
- (nonnull instancetype)initWithAccessToken:(NSString * _Nullable)accessToken host:(NSString * _Nullable)host OBJC_DESIGNATED_INITIALIZER;
/// Configures the router with the given set of tiles.
/// \param tilesURL The location where the tiles has been sideloaded to.
///
/// \param translationsURL The location where the translations has been downloaded to.
///
/// \param completionHandler A block that is called when the router is completely configured.
///
- (void)configureRouterWithTilesURL:(NSURL * _Nonnull)tilesURL translationsURL:(NSURL * _Nullable)translationsURL completionHandler:(void (^ _Nonnull)(uint64_t))completionHandler;
/// Unpacks a .tar-file at the given filePathURL to a writeable output directory.
/// The target at the filePathURL will be consumed while unpacking.
/// \param filePathURL The file path to the .tar-file.
///
/// \param outputDirectoryURL The output directory.
///
/// \param progressHandler Unpacking reports progress every 500ms.
///
/// \param completionHandler Called when unpacking completed.
///
+ (void)unpackTilePackAtURL:(NSURL * _Nonnull)filePathURL outputDirectoryURL:(NSURL * _Nonnull)outputDirectoryURL progressHandler:(void (^ _Nullable)(uint64_t, uint64_t))progressHandler completionHandler:(void (^ _Nullable)(uint64_t, NSError * _Nullable))completionHandler;
/// Begins asynchronously calculating the route or routes using the given options and delivers the results to a closure.
/// This method retrieves the routes asynchronously via MapboxNavigationNative.
/// Routes may be displayed atop a <a href="https://www.mapbox.com/maps/">Mapbox map</a>. They may be cached but may not be stored permanently. To use the results in other contexts or store them permanently, <a href="https://www.mapbox.com/navigation/#pricing">upgrade to a Mapbox enterprise plan</a>.
/// \param options A <code>RouteOptions</code> object specifying the requirements for the resulting routes.
///
/// \param offline Determines whether to calculate the route offline or online.
///
/// \param completionHandler The closure (block) to call with the resulting routes. This closure is executed on the application’s main thread.
///
- (void)calculateDirectionsWithOptions:(MBRouteOptions * _Nonnull)options offline:(BOOL)offline completionHandler:(void (^ _Nonnull)(NSArray<MBWaypoint *> * _Nullable, NSArray<MBRoute *> * _Nullable, NSError * _Nullable))completionHandler;
@end


/// The <code>NavigationEventsManager</code> is responsible for being the liaison between MapboxCoreNavigation and the Mapbox telemetry framework.
SWIFT_CLASS_NAMED("NavigationEventsManager")
@interface MBNavigationEventsManager : NSObject
- (nonnull instancetype)initWithDataSource:(id <EventsManagerDataSource> _Nullable)source accessToken:(NSString * _Nullable)possibleToken mobileEventsManager:(MMEEventsManager * _Nonnull)mobileEventsManager OBJC_DESIGNATED_INITIALIZER;
/// When set to <code>false</code>, flushing of telemetry events is not delayed. Is set to <code>true</code> by default.
@property (nonatomic) BOOL delaysEventFlushing;
/// Send feedback about the current road segment/maneuver to the Mapbox data team.
/// You can pair this with a custom feedback UI in your app to flag problems during navigation such as road closures, incorrect instructions, etc.
/// @param type A <code>FeedbackType</code> used to specify the type of feedback
/// @param description A custom string used to describe the problem in detail.
/// @return Returns a UUID used to identify the feedback event
/// If you provide a custom feedback UI that lets users elaborate on an issue, you should call this before you show the custom UI so the location and timestamp are more accurate.
/// You can then call <code>updateFeedback(uuid:type:source:description:)</code> with the returned feedback UUID to attach any additional metadata to the feedback.
- (NSUUID * _Nullable)recordFeedbackWithType:(enum MBFeedbackType)type description:(NSString * _Nullable)description SWIFT_WARN_UNUSED_RESULT;
/// Update the feedback event with a specific feedback identifier. If you implement a custom feedback UI that lets a user elaborate on an issue, you can use this to update the metadata.
/// Note that feedback is sent 20 seconds after being recorded, so you should promptly update the feedback metadata after the user discards any feedback UI.
- (void)updateFeedbackWithUuid:(NSUUID * _Nonnull)uuid type:(enum MBFeedbackType)type source:(enum MBFeedbackSource)source description:(NSString * _Nullable)description;
/// Discard a recorded feedback event, for example if you have a custom feedback UI and the user canceled feedback.
- (void)cancelFeedbackWithUuid:(NSUUID * _Nonnull)uuid;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end




/// <code>NavigationLocationManager</code> is the base location manager which handles permissions and background modes.
SWIFT_CLASS_NAMED("NavigationLocationManager")
@interface MBNavigationLocationManager : CLLocationManager
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


@interface MBNavigationLocationManager (SWIFT_EXTENSION(MapboxCoreNavigation)) <MBRouterDataSource>
@property (nonatomic, readonly) SWIFT_METATYPE(MBNavigationLocationManager) _Nonnull locationProvider;
@end


/// A <code>NavigationMatchOptions</code> object specifies turn-by-turn-optimized criteria for results returned by the Mapbox Map Matching API.
/// <code>NavigationMatchOptions</code> is a subclass of <code>MatchOptions</code> that has been optimized for navigation. Pass an instance of this class into the <code>Directions.calculateRoutes(matching:completionHandler:).</code> method.
/// Note: it is very important you specify the <code>waypoints</code> for the route. Usually the only two values for this <code>IndexSet</code> will be 0 and the length of the coordinates. Otherwise, all coordinates passed through will be considered waypoints.
SWIFT_CLASS_NAMED("NavigationMatchOptions")
@interface MBNavigationMatchOptions : MBMatchOptions
/// Initializes a navigation route options object for routes between the given waypoints and an optional profile identifier optimized for navigation.
/// seealso:
/// <code>MatchOptions</code>
- (nonnull instancetype)initWithWaypoints:(NSArray<MBWaypoint *> * _Nonnull)waypoints profileIdentifier:(MBDirectionsProfileIdentifier _Nullable)profileIdentifier OBJC_DESIGNATED_INITIALIZER;
/// Initializes a navigation match options object for routes between the given locations and an optional profile identifier optimized for navigation.
/// seealso:
/// <code>MatchOptions</code>
- (nonnull instancetype)initWithLocations:(NSArray<CLLocation *> * _Nonnull)locations profileIdentifier:(MBDirectionsProfileIdentifier _Nullable)profileIdentifier;
/// Initializes a navigation match options object for routes between the given geographic coordinates and an optional profile identifier optimized for navigation.
/// seealso:
/// <code>MatchOptions</code>
- (nonnull instancetype)initWithCoordinates:(NSArray<NSValue *> * _Nonnull)coordinates profileIdentifier:(MBDirectionsProfileIdentifier _Nullable)profileIdentifier;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder OBJC_DESIGNATED_INITIALIZER;
@end


/// A <code>NavigationRouteOptions</code> object specifies turn-by-turn-optimized criteria for results returned by the Mapbox Directions API.
/// <code>NavigationRouteOptions</code> is a subclass of <code>RouteOptions</code> that has been optimized for navigation. Pass an instance of this class into the <code>Directions.calculate(_:completionHandler:)</code> method.
/// note:
/// <code>NavigationRouteOptions</code> is designed to be used with the <code>Directions</code> and <code>NavigationDirections</code> classes for specifying routing criteria. To customize the user experience in a <code>NavigationViewController</code>, use the <code>NavigationOptions</code> class.
SWIFT_CLASS_NAMED("NavigationRouteOptions")
@interface MBNavigationRouteOptions : MBRouteOptions
/// Initializes a navigation route options object for routes between the given waypoints and an optional profile identifier optimized for navigation.
/// seealso:
/// <code>RouteOptions</code>
- (nonnull instancetype)initWithWaypoints:(NSArray<MBWaypoint *> * _Nonnull)waypoints profileIdentifier:(MBDirectionsProfileIdentifier _Nullable)profileIdentifier OBJC_DESIGNATED_INITIALIZER;
/// Initializes a navigation route options object for routes between the given locations and an optional profile identifier optimized for navigation.
/// seealso:
/// <code>RouteOptions</code>
- (nonnull instancetype)initWithLocations:(NSArray<CLLocation *> * _Nonnull)locations profileIdentifier:(MBDirectionsProfileIdentifier _Nullable)profileIdentifier;
/// Initializes a route options object for routes between the given geographic coordinates and an optional profile identifier optimized for navigation.
/// seealso:
/// <code>RouteOptions</code>
- (nonnull instancetype)initWithCoordinates:(NSArray<NSValue *> * _Nonnull)coordinates profileIdentifier:(MBDirectionsProfileIdentifier _Nullable)profileIdentifier;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder OBJC_DESIGNATED_INITIALIZER;
@end


enum MBNavigationSimulationIntent : NSInteger;

SWIFT_PROTOCOL("_TtP20MapboxCoreNavigation25NavigationServiceDelegate_")
@protocol NavigationServiceDelegate
@optional
/// Returns whether the navigation service should be allowed to calculate a new route.
/// If implemented, this method is called as soon as the navigation service detects that the user is off the predetermined route. Implement this method to conditionally prevent rerouting. If this method returns <code>true</code>, <code>navigationService(_:willRerouteFrom:)</code> will be called immediately afterwards.
/// \param service The navigation service that has detected the need to calculate a new route.
///
/// \param location The user’s current location.
///
///
/// returns:
/// True to allow the navigation service to calculate a new route; false to keep tracking the current route.
- (BOOL)navigationService:(id <MBNavigationService> _Nonnull)service shouldRerouteFromLocation:(CLLocation * _Nonnull)location SWIFT_WARN_UNUSED_RESULT;
/// Called immediately before the navigation service calculates a new route.
/// This method is called after <code>navigationService(_:shouldRerouteFrom:)</code> is called, simultaneously with the <code>NavigationServiceWillReroute</code> notification being posted, and before <code>navigationService(_:didRerouteAlong:)</code> is called.
/// \param service The navigation service that will calculate a new route.
///
/// \param location The user’s current location.
///
- (void)navigationService:(id <MBNavigationService> _Nonnull)service willRerouteFromLocation:(CLLocation * _Nonnull)location;
/// Called when a location has been identified as unqualified to navigate on.
/// See <code>CLLocation.isQualified</code> for more information about what qualifies a location.
/// <ul>
///   <li>
///     return: If <code>true</code>, the location is discarded and the <code>NavigationService</code> will not consider it. If <code>false</code>, the location will not be thrown out.
///   </li>
/// </ul>
/// \param service The navigation service that discarded the location.
///
/// \param location The location that will be discarded.
///
- (BOOL)navigationService:(id <MBNavigationService> _Nonnull)service shouldDiscardLocation:(CLLocation * _Nonnull)location SWIFT_WARN_UNUSED_RESULT;
/// Called immediately after the navigation service receives a new route.
/// This method is called after <code>navigationService(_:willRerouteFrom:)</code> and simultaneously with the <code>NavigationServiceDidReroute</code> notification being posted.
/// \param service The navigation service that has calculated a new route.
///
/// \param route The new route.
///
- (void)navigationService:(id <MBNavigationService> _Nonnull)service didRerouteAlongRoute:(MBRoute * _Nonnull)route at:(CLLocation * _Nullable)location proactive:(BOOL)proactive;
/// Called when the navigation service fails to receive a new route.
/// This method is called after <code>navigationService(_:willRerouteFrom:)</code> and simultaneously with the <code>NavigationServiceDidFailToReroute</code> notification being posted.
/// \param service The navigation service that has calculated a new route.
///
/// \param error An error raised during the process of obtaining a new route.
///
- (void)navigationService:(id <MBNavigationService> _Nonnull)service didFailToRerouteWithError:(NSError * _Nonnull)error;
/// Called when the navigation service updates the route progress model.
/// \param service The navigation service that received the new locations.
///
/// \param progress the RouteProgress model that was updated.
///
/// \param location the guaranteed location, possibly snapped, associated with the progress update.
///
/// \param rawLocation the raw location, from the location manager, associated with the progress update.
///
- (void)navigationService:(id <MBNavigationService> _Nonnull)service didUpdateProgress:(MBRouteProgress * _Nonnull)progress withLocation:(CLLocation * _Nonnull)location rawLocation:(CLLocation * _Nonnull)rawLocation;
/// Called when the navigation service detects that the user has passed a point at which an instruction should be displayed.
/// \param service The navigation service that passed the instruction point.
///
/// \param instruction The instruction to be presented.
///
/// \param routeProgress The route progress object that the navigation service is updating.
///
- (void)navigationService:(id <MBNavigationService> _Nonnull)service didPassVisualInstructionPoint:(MBVisualInstructionBanner * _Nonnull)instruction routeProgress:(MBRouteProgress * _Nonnull)routeProgress;
/// Called when the navigation service detects that the user has passed a point at which an instruction should be spoken.
/// \param service The navigation service that passed the instruction point.
///
/// \param instruction The instruction to be spoken.
///
/// \param routeProgress The route progress object that the navigation service is updating.
///
- (void)navigationService:(id <MBNavigationService> _Nonnull)service didPassSpokenInstructionPoint:(MBSpokenInstruction * _Nonnull)instruction routeProgress:(MBRouteProgress * _Nonnull)routeProgress;
/// Called as the navigation service approaches a waypoint.
/// This message is sent, once per progress update, as the user is approaching a waypoint. You can use this to cue UI, to do network pre-loading, etc.
/// important:
/// This method will likely be called several times as you approach a destination. If only one consumption of this method is desired, then usage of an internal flag is recommended.
/// \param service The Navigation service that is detecting the destination approach.
///
/// \param waypoint The waypoint that the service is arriving at.
///
/// \param remainingTimeInterval The estimated number of seconds until arrival.
///
/// \param distance The current distance from the waypoint, in meters.
///
- (void)navigationService:(id <MBNavigationService> _Nonnull)service willArriveAtWaypoint:(MBWaypoint * _Nonnull)waypoint after:(NSTimeInterval)remainingTimeInterval distance:(CLLocationDistance)distance;
/// Called when the navigation service arrives at a waypoint.
/// You can implement this method to prevent the navigation service from automatically advancing to the next leg. For example, you can and show an interstitial sheet upon arrival and pause navigation by returning <code>false</code>, then continue the route when the user dismisses the sheet. If this method is unimplemented, the navigation service automatically advances to the next leg when arriving at a waypoint.
/// postcondition:
/// If you return false, you must manually advance to the next leg: obtain the value of the <code>routeProgress</code> property, then increment the <code>RouteProgress.legIndex</code> property.
/// \param service The navigation service that has arrived at a waypoint.
///
/// \param waypoint The waypoint that the controller has arrived at.
///
///
/// returns:
/// True to advance to the next leg, if any, or false to remain on the completed leg.
- (BOOL)navigationService:(id <MBNavigationService> _Nonnull)service didArriveAtWaypoint:(MBWaypoint * _Nonnull)waypoint SWIFT_WARN_UNUSED_RESULT;
/// Called when the navigation service arrives at a waypoint.
/// You can implement this method to allow the navigation service to continue check and reroute the user if needed. By default, the user will not be rerouted when arriving at a waypoint.
/// \param service The navigation service that has arrived at a waypoint.
///
/// \param waypoint The waypoint that the controller has arrived at.
///
///
/// returns:
/// True to prevent the navigation service from checking if the user should be rerouted.
- (BOOL)navigationService:(id <MBNavigationService> _Nonnull)service shouldPreventReroutesWhenArrivingAtWaypoint:(MBWaypoint * _Nonnull)waypoint SWIFT_WARN_UNUSED_RESULT;
/// Called when the navigation service will disable battery monitoring.
/// Implementing this method will allow developers to change whether battery monitoring is disabled when <code>NavigationService</code> is deinited.
/// \param service The navigation service that will change the state of battery monitoring.
///
///
/// returns:
/// A bool indicating whether to disable battery monitoring when the RouteController is deinited.
- (BOOL)navigationServiceShouldDisableBatteryMonitoring:(id <MBNavigationService> _Nonnull)service SWIFT_WARN_UNUSED_RESULT;
/// Called when the navigation service is about to begin location simulation.
/// Implementing this method will allow developers to react when “poor GPS” location-simulation is about to start, possibly to show a “Poor GPS” banner in the UI.
/// \param service The navigation service that will simulate the routes’ progress.
///
/// \param progress the current RouteProgress model.
///
/// \param reason The reason the simulation will be initiated. Either manual or poorGPS.
///
- (void)navigationService:(id <MBNavigationService> _Nonnull)service willBeginSimulating:(MBRouteProgress * _Nonnull)progress becauseOf:(enum MBNavigationSimulationIntent)reason;
/// Called after the navigation service begins location simulation.
/// Implementing this method will allow developers to react when “poor GPS” location-simulation has started, possibly to show a “Poor GPS” banner in the UI.
/// \param service The navigation service that is simulating the routes’ progress.
///
/// \param progress the current RouteProgress model.
///
/// \param reason The reason the simulation has been initiated. Either manual or poorGPS.
///
- (void)navigationService:(id <MBNavigationService> _Nonnull)service didBeginSimulating:(MBRouteProgress * _Nonnull)progress becauseOf:(enum MBNavigationSimulationIntent)reason;
/// Called when the navigation service is about to end location simulation.
/// Implementing this method will allow developers to react when “poor GPS” location-simulation is about to end, possibly to hide a “Poor GPS” banner in the UI.
/// \param service The navigation service that is simulating the routes’ progress.
///
/// \param progress the current RouteProgress model.
///
/// \param reason The reason the simulation was initiated. Either manual or poorGPS.
///
- (void)navigationService:(id <MBNavigationService> _Nonnull)service willEndSimulating:(MBRouteProgress * _Nonnull)progress becauseOf:(enum MBNavigationSimulationIntent)reason;
/// Called after the navigation service ends location simulation.
/// Implementing this method will allow developers to react when “poor GPS” location-simulation has ended, possibly to hide a “Poor GPS” banner in the UI.
/// \param service The navigation service that was simulating the routes’ progress.
///
/// \param progress the current RouteProgress model.
///
/// \param reason The reason the simulation was initiated. Either manual or poorGPS.
///
- (void)navigationService:(id <MBNavigationService> _Nonnull)service didEndSimulating:(MBRouteProgress * _Nonnull)progress becauseOf:(enum MBNavigationSimulationIntent)reason;
@end


/// <code>NavigationSettings</code> provides a wrapper for UserDefaults.
/// Properties are prefixed and before they are stored in UserDefaults.standard.
SWIFT_CLASS_NAMED("NavigationSettings")
@interface MBNavigationSettings : NSObject
/// The volume that the voice controller will use.
/// This volume is relative to the system’s volume where 1.0 is same volume as the system.
@property (nonatomic) float voiceVolume;
/// Specifies whether to mute the voice controller or not.
@property (nonatomic) BOOL voiceMuted;
/// Specifies the preferred distance measurement unit.
/// note:
/// Anything but <code>kilometer</code> and <code>mile</code> will fall back to the default measurement for the current locale.
/// Meters and feets will be used when the presented distances are small enough. See <code>DistanceFormatter</code> for more information.
@property (nonatomic) NSLengthFormatterUnit distanceUnit;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) MBNavigationSettings * _Nonnull sharedSettings;)
+ (MBNavigationSettings * _Nonnull)sharedSettings SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
- (void)observeValueForKeyPath:(NSString * _Nullable)keyPath ofObject:(id _Nullable)object change:(NSDictionary<NSKeyValueChangeKey, id> * _Nullable)change context:(void * _Nullable)context;
@end




/// <code>ReplayLocationManager</code> replays an array of locations exactly as they were
/// recorded with the single exception of the location’s timestamp which will be
/// adjusted by interval between locations.
SWIFT_CLASS_NAMED("ReplayLocationManager")
@interface MBReplayLocationManager : MBNavigationLocationManager
/// <code>speedMultiplier</code> adjusts the speed of the replay.
@property (nonatomic) NSTimeInterval speedMultiplier;
/// <code>locations</code> to be replayed.
@property (nonatomic, copy) NSArray<CLLocation *> * _Null_unspecified locations;
@property (nonatomic, strong) CLLocation * _Nullable location;
- (void)startUpdatingLocation;
- (void)stopUpdatingLocation;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end

@class MBNavigatorConfig;

/// A <code>RouteController</code> tracks the user’s progress along a route, posting notifications as the user reaches significant points along the route. On every location update, the route controller evaluates the user’s location, determining whether the user remains on the route. If not, the route controller calculates a new route.
/// <code>RouteController</code> is responsible for the core navigation logic whereas
/// <code>NavigationViewController</code> is responsible for displaying a default drop-in navigation UI.
SWIFT_CLASS_NAMED("RouteController")
@interface MBRouteController : NSObject
@property (nonatomic, strong) MBRoute * _Nonnull route;
@property (nonatomic, strong) MBNavigatorConfig * _Nullable config;
/// Details about the user’s progress along the current route, leg, and step.
@property (nonatomic, strong) MBRouteProgress * _Nonnull routeProgress;
/// The route controller’s delegate.
@property (nonatomic, weak) id <MBRouterDelegate> _Nullable delegate;
/// The route controller’s associated location manager.
@property (nonatomic, assign) id <MBRouterDataSource> _Nonnull dataSource;
/// The Directions object used to create the route.
@property (nonatomic, strong) MBDirections * _Nonnull directions;
/// The idealized user location. Snapped to the route line, if applicable, otherwise raw.
/// seealso:
/// snappedLocation, rawLocation
@property (nonatomic, readonly, strong) CLLocation * _Nullable location;
- (nonnull instancetype)initWithRoute:(MBRoute * _Nonnull)route directions:(MBDirections * _Nonnull)directions dataSource:(id <MBRouterDataSource> _Nonnull)source OBJC_DESIGNATED_INITIALIZER;
- (void)locationManager:(CLLocationManager * _Nonnull)manager didUpdateLocations:(NSArray<CLLocation *> * _Nonnull)locations;
- (void)advanceLegIndexWithLocation:(CLLocation * _Nonnull)location;
- (void)enableLocationRecording;
- (void)disableLocationRecording;
- (NSString * _Nonnull)locationHistory SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end


@interface MBRouteController (SWIFT_EXTENSION(MapboxCoreNavigation)) <Router>
- (BOOL)userIsOnRoute:(CLLocation * _Nonnull)location SWIFT_WARN_UNUSED_RESULT;
- (void)rerouteFrom:(CLLocation * _Nonnull)location along:(MBRouteProgress * _Nonnull)progress;
@end

@class MBRouteLeg;
@class MBRouteStep;
@class MBRouteStepProgress;

/// <code>RouteLegProgress</code> stores the user’s progress along a route leg.
SWIFT_CLASS_NAMED("RouteLegProgress")
@interface MBRouteLegProgress : NSObject
/// Returns the current <code>RouteLeg</code>.
@property (nonatomic, readonly, strong) MBRouteLeg * _Nonnull leg;
/// Index representing the current step.
@property (nonatomic) NSInteger stepIndex;
/// The remaining steps for user to complete.
@property (nonatomic, readonly, copy) NSArray<MBRouteStep *> * _Nonnull remainingSteps;
/// Total distance traveled in meters along current leg.
@property (nonatomic, readonly) CLLocationDistance distanceTraveled;
/// Duration remaining in seconds on current leg.
@property (nonatomic, readonly) NSTimeInterval durationRemaining;
/// Distance remaining on the current leg.
@property (nonatomic, readonly) CLLocationDistance distanceRemaining;
/// Number between 0 and 1 representing how far along the current leg the user has traveled.
@property (nonatomic, readonly) double fractionTraveled;
@property (nonatomic) BOOL userHasArrivedAtWaypoint;
/// Returns the <code>RouteStep</code> before a given step. Returns <code>nil</code> if there is no step prior.
- (MBRouteStep * _Nullable)stepBefore:(MBRouteStep * _Nonnull)step SWIFT_WARN_UNUSED_RESULT;
/// Returns the <code>RouteStep</code> after a given step. Returns <code>nil</code> if there is not a step after.
- (MBRouteStep * _Nullable)stepAfter:(MBRouteStep * _Nonnull)step SWIFT_WARN_UNUSED_RESULT;
/// Returns the <code>RouteStep</code> before the current step.
/// If there is no <code>priorStep</code>, nil is returned.
@property (nonatomic, readonly, strong) MBRouteStep * _Nullable priorStep;
/// Returns the current <code>RouteStep</code> for the leg the user is on.
@property (nonatomic, readonly, strong) MBRouteStep * _Nonnull currentStep;
/// Returns the upcoming <code>RouteStep</code>.
/// If there is no <code>upcomingStep</code>, nil is returned.
@property (nonatomic, readonly, strong) MBRouteStep * _Nullable upComingStep SWIFT_DEPRECATED_MSG("", "upcomingStep");
@property (nonatomic, readonly, strong) MBRouteStep * _Nullable upcomingStep;
/// Returns step 2 steps ahead.
/// If there is no <code>followOnStep</code>, nil is returned.
@property (nonatomic, readonly, strong) MBRouteStep * _Nullable followOnStep;
/// Return bool whether step provided is the current <code>RouteStep</code> the user is on.
- (BOOL)isCurrentStep:(MBRouteStep * _Nonnull)step SWIFT_WARN_UNUSED_RESULT;
/// Returns the progress along the current <code>RouteStep</code>.
@property (nonatomic, strong) MBRouteStepProgress * _Nonnull currentStepProgress;
/// Intializes a new <code>RouteLegProgress</code>.
/// \param leg Leg on a <code>Route</code>.
///
/// \param stepIndex Current step the user is on.
///
- (nonnull instancetype)initWithLeg:(MBRouteLeg * _Nonnull)leg stepIndex:(NSInteger)stepIndex spokenInstructionIndex:(NSInteger)spokenInstructionIndex OBJC_DESIGNATED_INITIALIZER;
/// Returns an array of <code>CLLocationCoordinate2D</code> of the prior, current and upcoming step geometry.
@property (nonatomic, readonly, copy) NSArray<NSValue *> * _Nonnull nearbyCoordinates;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end






/// <code>RouteProgress</code> stores the user’s progress along a route.
SWIFT_CLASS_NAMED("RouteProgress")
@interface MBRouteProgress : NSObject
/// Returns the current <code>Route</code>.
@property (nonatomic, readonly, strong) MBRoute * _Nonnull route;
/// Index representing current <code>RouteLeg</code>.
@property (nonatomic) NSInteger legIndex;
/// If waypoints are provided in the <code>Route</code>, this will contain which leg the user is on.
@property (nonatomic, readonly, strong) MBRouteLeg * _Nonnull currentLeg;
/// Returns the remaining legs left on the current route
@property (nonatomic, readonly, copy) NSArray<MBRouteLeg *> * _Nonnull remainingLegs;
/// Returns the remaining steps left on the current route
@property (nonatomic, readonly, copy) NSArray<MBRouteStep *> * _Nonnull remainingSteps;
/// Total distance traveled by user along all legs.
@property (nonatomic, readonly) CLLocationDistance distanceTraveled;
/// Total seconds remaining on all legs.
@property (nonatomic, readonly) NSTimeInterval durationRemaining;
/// Number between 0 and 1 representing how far along the <code>Route</code> the user has traveled.
@property (nonatomic, readonly) double fractionTraveled;
/// Total distance remaining in meters along route.
@property (nonatomic, readonly) CLLocationDistance distanceRemaining;
/// Number of waypoints remaining on the current route.
@property (nonatomic, readonly, copy) NSArray<MBWaypoint *> * _Nonnull remainingWaypoints;
/// Returns the progress along the current <code>RouteLeg</code>.
@property (nonatomic, strong) MBRouteLegProgress * _Nonnull currentLegProgress;
@property (nonatomic, readonly, strong) MBRouteLeg * _Nullable priorLeg;
/// The step prior to the current step along this route.
/// The prior step may be part of a different RouteLeg than the current step. If the current step is the first step along the route, this property is set to nil.
@property (nonatomic, readonly, strong) MBRouteStep * _Nullable priorStep;
/// The leg following the current leg along this route.
/// If this leg is the last leg of the route, this property is set to nil.
@property (nonatomic, readonly, strong) MBRouteLeg * _Nullable upcomingLeg;
/// Returns an array of <code>CLLocationCoordinate2D</code> of the coordinates along the current step and any adjacent steps.
/// important:
/// The adjacent steps may be part of legs other than the current leg.
@property (nonatomic, readonly, copy) NSArray<NSValue *> * _Nonnull nearbyCoordinates;
/// Intializes a new <code>RouteProgress</code>.
/// \param route The route to follow.
///
/// \param legIndex Zero-based index indicating the current leg the user is on.
///
- (nonnull instancetype)initWithRoute:(MBRoute * _Nonnull)route legIndex:(NSInteger)legIndex spokenInstructionIndex:(NSInteger)spokenInstructionIndex OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end



@class MBIntersection;

/// <code>RouteStepProgress</code> stores the user’s progress along a route step.
SWIFT_CLASS_NAMED("RouteStepProgress")
@interface MBRouteStepProgress : NSObject
/// Returns the current <code>RouteStep</code>.
@property (nonatomic, readonly, strong) MBRouteStep * _Nonnull step;
/// Returns distance user has traveled along current step.
@property (nonatomic) CLLocationDistance distanceTraveled;
/// Returns distance from user to end of step.
@property (nonatomic) CLLocationDistance userDistanceToManeuverLocation;
/// Total distance in meters remaining on current step.
@property (nonatomic, readonly) CLLocationDistance distanceRemaining;
/// Number between 0 and 1 representing fraction of current step traveled.
@property (nonatomic, readonly) double fractionTraveled;
/// Number of seconds remaining on current step.
@property (nonatomic, readonly) NSTimeInterval durationRemaining;
/// Intializes a new <code>RouteStepProgress</code>.
/// \param step Step on a <code>RouteLeg</code>.
///
- (nonnull instancetype)initWithStep:(MBRouteStep * _Nonnull)step spokenInstructionIndex:(NSInteger)spokenInstructionIndex OBJC_DESIGNATED_INITIALIZER;
/// All intersections on the current <code>RouteStep</code> and also the first intersection on the upcoming <code>RouteStep</code>.
/// The upcoming <code>RouteStep</code> first <code>Intersection</code> is added because it is omitted from the current step.
@property (nonatomic, copy) NSArray<MBIntersection *> * _Nullable intersectionsIncludingUpcomingManeuverIntersection;
/// The next intersection the user will travel through.
/// The step must contain <code>intersectionsIncludingUpcomingManeuverIntersection</code> otherwise this property will be <code>nil</code>.
@property (nonatomic, readonly, strong) MBIntersection * _Nullable upcomingIntersection;
/// Index representing the current intersection.
@property (nonatomic) NSInteger intersectionIndex;
/// The current intersection the user will travel through.
/// The step must contain <code>intersectionsIncludingUpcomingManeuverIntersection</code> otherwise this property will be <code>nil</code>.
@property (nonatomic, readonly, strong) MBIntersection * _Nullable currentIntersection;
/// Returns an array of the calculated distances from the current intersection to the next intersection on the current step.
@property (nonatomic, copy) NSArray<NSNumber *> * _Nullable intersectionDistances;
/// Index into <code>step.instructionsDisplayedAlongStep</code> representing the current visual instruction for the step.
@property (nonatomic) NSInteger visualInstructionIndex;
/// An <code>Array</code> of remaining <code>VisualInstruction</code> for a step.
@property (nonatomic, readonly, copy) NSArray<MBVisualInstructionBanner *> * _Nullable remainingVisualInstructions;
/// Index into <code>step.instructionsSpokenAlongStep</code> representing the current spoken instruction.
@property (nonatomic) NSInteger spokenInstructionIndex;
/// An <code>Array</code> of remaining <code>SpokenInstruction</code> for a step.
@property (nonatomic, readonly, copy) NSArray<MBSpokenInstruction *> * _Nullable remainingSpokenInstructions;
/// Current spoken instruction for the user’s progress along a step.
@property (nonatomic, readonly, strong) MBSpokenInstruction * _Nullable currentSpokenInstruction;
/// Current visual instruction for the user’s progress along a step.
@property (nonatomic, readonly, strong) MBVisualInstructionBanner * _Nullable currentVisualInstruction;
@property (nonatomic, readonly, copy) NSSet<NSString *> * _Nonnull keyPathsAffectingValueForRemainingVisualInstructions;
@property (nonatomic, readonly, copy) NSSet<NSString *> * _Nonnull keyPathsAffectingValueForRemainingSpokenInstructions;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end





/// The <code>SimulatedLocationManager</code> class simulates location updates along a given route.
/// The route will be replaced upon a <code>RouteControllerDidReroute</code> notification.
SWIFT_CLASS_NAMED("SimulatedLocationManager")
@interface MBSimulatedLocationManager : MBNavigationLocationManager
/// Specify the multiplier to use when calculating speed based on the RouteLeg’s <code>expectedSegmentTravelTimes</code>.
@property (nonatomic) double speedMultiplier;
@property (nonatomic, strong) CLLocation * _Nullable location;
- (id _Nonnull)copy SWIFT_WARN_UNUSED_RESULT;
/// Initalizes a new <code>SimulatedLocationManager</code> with the given route.
/// \param route The initial route.
///
///
/// returns:
/// A <code>SimulatedLocationManager</code>
- (nonnull instancetype)initWithRoute:(MBRoute * _Nonnull)route OBJC_DESIGNATED_INITIALIZER;
/// Initalizes a new <code>SimulatedLocationManager</code> with the given routeProgress.
/// \param routeProgress The routeProgress of the current route.
///
///
/// returns:
/// A <code>SimulatedLocationManager</code>
- (nonnull instancetype)initWithRouteProgress:(MBRouteProgress * _Nonnull)routeProgress OBJC_DESIGNATED_INITIALIZER;
- (void)startUpdatingLocation;
- (void)stopUpdatingLocation;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end

typedef SWIFT_ENUM_NAMED(NSInteger, MBNavigationSimulationIntent, "SimulationIntent", closed) {
  MBNavigationSimulationIntentManual = 0,
  MBNavigationSimulationIntentPoorGPS = 1,
};

/// The simulation mode type. Used for setting the simulation mode of the navigation service.
typedef SWIFT_ENUM_NAMED(NSInteger, MBNavigationSimulationOptions, "SimulationMode", closed) {
/// A setting of <code>.onPoorGPS</code> will enable simulation when we do not recieve a location update after the <code>poorGPSPatience</code> threshold has elapsed.
  MBNavigationSimulationOptionsOnPoorGPS = 0,
/// A setting of <code>.always</code> will simulate route progress at all times.
  MBNavigationSimulationOptionsAlways = 1,
/// A setting of <code>.never</code> will never enable the location simulator, regardless of circumstances.
  MBNavigationSimulationOptionsNever = 2,
};




@interface UIDevice (SWIFT_EXTENSION(MapboxCoreNavigation))
/// Returns a <code>Bool</code> whether the device is plugged in. Returns false if not an iOS device.
@property (nonatomic, readonly) BOOL isPluggedIn;
@end





#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop
